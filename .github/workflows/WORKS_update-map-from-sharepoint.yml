name: Update map data from SharePoint with Geocoding

on:
  workflow_dispatch: {}
  schedule:
    - cron: "0 7 * * *"
    - cron: "0 8 * * *"

permissions:
  contents: write

jobs:
  update-json:
    runs-on: windows-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Pull SharePoint list, geocode, and build JSON
        shell: pwsh
        env:
          GRAPH_TENANT_ID: ${{ secrets.GRAPH_TENANT_ID }}
          GRAPH_CLIENT_ID: ${{ secrets.GRAPH_CLIENT_ID }}
          GRAPH_CLIENT_SECRET: ${{ secrets.GRAPH_CLIENT_SECRET }}
          SP_SITE_HOSTNAME: ${{ secrets.SP_SITE_HOSTNAME }}
          SP_SITE_PATH: ${{ secrets.SP_SITE_PATH }}
          SP_SITE_ID: ${{ secrets.SP_SITE_ID }}
        run: |
          # ---- Get Graph token (client credentials) ----
          $body = @{
            client_id     = $env:GRAPH_CLIENT_ID
            scope         = "https://graph.microsoft.com/.default"
            client_secret = $env:GRAPH_CLIENT_SECRET
            grant_type    = "client_credentials"
          }
          $tok = Invoke-RestMethod -Method Post -Uri ("https://login.microsoftonline.com/{0}/oauth2/v2.0/token" -f $env:GRAPH_TENANT_ID) -Body $body
          if (-not $tok.access_token) { throw "No Graph token returned." }
          $H = @{ Authorization = "Bearer $($tok.access_token)" }

          # ---- Resolve site (SP_SITE_ID wins; else robust host/path) ----
          if ($env:SP_SITE_ID -and $env:SP_SITE_ID.Trim()) {
            $siteId = $env:SP_SITE_ID.Trim()
            Write-Host ("Debug: Using provided SP_SITE_ID: {0}" -f $siteId)
          } else {
            $spHost = ($env:SP_SITE_HOSTNAME ?? "").Trim()
            $rawPath = ($env:SP_SITE_PATH ?? "").Trim()
            if (-not $spHost) { throw "SP_SITE_HOSTNAME is empty. Expect 'gatewaymgt.sharepoint.com'." }
            if (-not $rawPath) { throw "SP_SITE_PATH is empty. Expect 'sites/Intranet'." }
            if ($spHost -match '^https?://') { $spHost = $spHost -replace '^https?://','' }
            $spHost = $spHost.TrimEnd('/')

            Write-Host ("Debug: HOST.len={0} PATH.len={1}" -f $spHost.Length, $rawPath.Length)

            $rawPath = $rawPath.TrimStart('/')
            $candidates = @()
            if ($rawPath -match '^(sites|teams)/') {
              $candidates += $rawPath
            } else {
              $candidates += $rawPath
              $candidates += ("sites/{0}" -f $rawPath)
              $candidates += ("teams/{0}" -f $rawPath)
            }

            $site = $null
            foreach ($p in ($candidates | Select-Object -Unique)) {
              $siteUri = "https://graph.microsoft.com/v1.0/sites/${spHost}:/${p}"
              Write-Host ("Debug: Try {0}" -f $siteUri)
              try {
                $tmp = Invoke-RestMethod -Headers $H -Uri $siteUri -Method GET -ErrorAction Stop
                if ($tmp -and $tmp.id) { $site = $tmp; $spPath = $p; break }
              } catch { }
            }

            if (-not $site) {
              $needle = ($rawPath.Split('/') | Select-Object -Last 1)
              Write-Host ("Debug: Fallback search for '{0}'" -f $needle)
              try {
                $search = Invoke-RestMethod -Headers $H -Uri ("https://graph.microsoft.com/v1.0/sites?`$search={0}" -f $needle) -Method GET
                if ($search.value) {
                  $cands = $search.value | Where-Object { $_.webUrl -like ("https://{0}/*" -f $spHost) }
                  $targetUrl = "https://{0}/{1}" -f $spHost, $rawPath
                  $site = $cands | Sort-Object `
                    @{Expression={ $_.webUrl -eq $targetUrl }; Descending=$true},
                    @{Expression={ $_.webUrl -match ('/{0}(/|$)' -f [regex]::Escape($rawPath)) }; Descending=$true},
                    @{Expression={ $_.webUrl.Length }; Descending=$true} |
                    Select-Object -First 1
                }
              } catch { }
            }

            if (-not $site -or -not $site.id) {
              $tried = ($candidates -join ', ')
              throw ("Could not resolve site. Host='{0}' PathCandidates=[{1}] Ensure host like 'gatewaymgt.sharepoint.com' and path like 'sites/Intranet'. You can also set SP_SITE_ID to bypass." -f $spHost, $tried)
            }

            $siteId = $site.id
            Write-Host ("Debug: Resolved SiteId: {0}" -f $siteId)
            Write-Host ("Debug: Site WebUrl: {0}" -f $site.webUrl)
          }

          # ---- Resolve list (enumerate then match; no $filter brittleness) ----
          $listName = "Properties_by_RVP"
          $listsUrl = "https://graph.microsoft.com/v1.0/sites/$siteId/lists?`$select=id,displayName&`$top=999"
          $lists = Invoke-RestMethod -Headers $H -Uri $listsUrl -Method GET
          if (-not $lists.value) { throw ("Graph returned zero lists for site id {0}." -f $siteId) }

          $list = $lists.value | Where-Object { $_.displayName -eq $listName }
          if (-not $list) { $list = $lists.value | Where-Object { $_.displayName.ToLower() -eq $listName.ToLower() } }
          if (-not $list) {
            $alt = ($listName -replace '_',' ')
            $list = $lists.value | Where-Object { $_.displayName.ToLower() -eq $alt.ToLower() }
          }
          if (-not $list) {
            throw ("List '{0}' not found. Available: {1}" -f $listName, ($lists.value.displayName -join ', '))
          }

          $listId = $list.id
          Write-Host ("Debug: Using list: {0} ({1})" -f $list.displayName, $listId)

          # ---- Pull all items (expand fields) ----
          $items = @()
          $url = "https://graph.microsoft.com/v1.0/sites/$siteId/lists/$listId/items?`$expand=fields&`$top=999"
          while ($url) {
            $r = Invoke-RestMethod -Headers $H -Uri $url -Method GET
            $items += $r.value
            $url = $r.'@odata.nextLink'
          }

          # ---- First run helper: dump detected internal field names ----
          if ($items.Count -gt 0) {
            ($items[0].fields | Get-Member -MemberType NoteProperty | Select-Object -ExpandProperty Name) |
              Sort-Object | Out-File -Encoding utf8 -FilePath "$PWD/detected_sharepoint_fields.txt"
          }

          # ---- Map SharePoint fields -> map schema (initial pass) ----
          function Map-Row($f) {
            [pscustomobject]@{
              name           = $f.Title
              type           = $f.TYPE
              units          = $f.field_2
              manager        = $f.field_3
              assistant_mgr  = $f.field_4
              compliance     = $f.field_5
              address        = $f.field_6
              city           = $f.field_7
              state          = $f.field_8
              zip            = $f.field_9
              office_phone   = $f.field_10
              fax            = $f.field_11
              manager_email  = $f.field_12
              rpm            = $f.field_13
              rvp            = $f.field_14
              owner          = $f.Owner
              legal_entity   = $f.LegalEntity
              lat            = [double]($f.Latitude ?? 0.0)
              lng            = [double]($f.Longitude ?? 0.0)
            }
          }

          $out = foreach ($it in $items) { Map-Row $it.fields }

          # ---- Load geocache if exists ----
          $geocacheFile = "geocache.json"
          $geocache = @{}
          if (Test-Path $geocacheFile) {
            $geocache = Get-Content $geocacheFile -Raw | ConvertFrom-Json -AsHashtable
          }

          # ---- Geocode properties with missing coords ----
          foreach ($prop in $out) {
            if ($prop.lat -eq 0.0 -and $prop.lng -eq 0.0) {
              $addr = "$($prop.address), $($prop.city), $($prop.state) $($prop.zip)"
              $addr = $addr -replace 'Hwy', 'Highway' -replace '\s+', ' ' # Clean address
              $addrKey = $addr -replace '[^a-zA-Z0-9]', '' # Simple cache key
              if ($geocache.ContainsKey($addrKey)) {
                Write-Host ("Cache hit for {0}: ({1}, {2})" -f $addr, $geocache[$addrKey].lat, $geocache[$addrKey].lng)
                $prop.lat = $geocache[$addrKey].lat
                $prop.lng = $geocache[$addrKey].lng
              } else {
                Write-Host ("Geocoding {0}" -f $addr)
                $encodedAddr = [System.Web.HttpUtility]::UrlEncode($addr)
                $gurl = "https://nominatim.openstreetmap.org/search?q=$encodedAddr&format=json&limit=1"
                try {
                  $response = Invoke-RestMethod -Uri $gurl -Headers @{ "User-Agent" = "GatewayMapBot/1.0 (bot@example.com)" } -Method GET
                  if ($response -and $response.Count -gt 0) {
                    $prop.lat = [double]$response[0].lat
                    $prop.lng = [double]$response[0].lon
                    $geocache[$addrKey] = @{ lat = $prop.lat; lng = $prop.lng }
                    Write-Host ("Geocoded {0} to ({1}, {2})" -f $addr, $prop.lat, $prop.lng)
                  } else {
                    Write-Host ("No coords found for {0}" -f $addr)
                  }
                } catch {
                  Write-Host ("Geocoding failed for {0}: {1}" -f $addr, $_)
                }
                Start-Sleep -Milliseconds 1000 # Nominatim 1 req/sec limit
              }
            } else {
              Write-Host ("Using existing coords for {0}: ({1}, {2})" -f $prop.address, $prop.lat, $prop.lng)
            }
          }

          # ---- Save geocache ----
          $geocache | ConvertTo-Json -Depth 4 | Set-Content -Encoding utf8 -Path $geocacheFile

          # ---- Backup previous JSON if exists ----
          $jsonFile = "final_properties_with_coords_and_rvp.json"
          if (Test-Path $jsonFile) {
            $stamp = Get-Date -Format "yyyyMMdd-HHmmss"
            Copy-Item $jsonFile ("backup_final_properties_{0}.json" -f $stamp)
          }

          # ---- Write JSON expected by the frontend ----
          $out | ConvertTo-Json -Depth 4 | Set-Content -Encoding utf8 -Path $jsonFile
          Write-Host ("Wrote {0} with {1} rows." -f $jsonFile, $out.Count)

      - name: Set git identity (fallback)
        shell: bash
        run: |
          git config --global user.name "Gateway Map Bot"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Commit JSON (and first-time field list)
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: 'Auto-update: final_properties_with_coords_and_rvp.json from SharePoint with geocoding'
          file_pattern: |
            final_properties_with_coords_and_rvp.json
            backup_final_properties_*.json
            detected_sharepoint_fields.txt
            geocache.json
          commit_user_name: 'Gateway Map Bot'
          commit_user_email: 'github-actions[bot]@users.noreply.github.com'
          commit_author: 'Gateway Map Bot <github-actions[bot]@users.noreply.github.com>'
